Strong Accept

Pros: 
- A new novel approach to database testing 
- Works on actual database (no mock database) 

Cons: 
- No evaluation yet. 



Overall, I think the paper is written really well, and the idea is 
novel. I enjoyed reading the paper. 

I like the motivation that right now we have big data everywhere, and 
lots of applications will be built on top of this data. Hence these 
applications should be tested on *real* data rather than on a mock 
database. 

Another intuition that I like is that the authors try to map 
the problem of code coverage (e.g. if-else coverage) into 
the problem of generating query results that will increase 
the code coverage. To me, the WHERE clause of a query is 
essentially also in the form of if-else. So these two 
problems map really well, and symbolic execution works 
well for this problem. Nice! 


Some concerns/comments: 

I think this testing framework is more appropriate for application 
that mostly reads data. For application that writes data, the testing 
setup might be more tricky. Here's the problem: we're still testing 
the application, so the application might have lots of bugs. If the 
application can modify the database, we don't want the application to 
run on the *actual* database, or otherwise you'll corrupt the actual 
database during testing. So the only way is to replicate the 
database, which might be expensive -- more coverage means more data is 
needed. So, potentially if the database is big, then you need to 
mirror the whole database. 

Another case of slower testing might be possible here. For example, 
say if the actual data is big, and hence cannot reside in memory all 
the time, and your new generated queries perform random access, or 
access on non-indexed column. On other hand, mock database tends 
to be small and fit in memory. 

In section 4.2, you have some equations for coverage. I'd love to see 
real empirical evaluations based on these equations. 

In Related Work and Motivation, you claim that "actual data" is 
important for several software engineering tasks. I still don't get 
the full story. I think this will be clear if there is some empirical 
evaluation on the effectiveness of mock database vs. your approach. 

In the motivation, I'd love to understand why creating 
a mock database is hard. 



Typos 

"we only use DBMS can estimate" ? 
", I.e.," 

=================================================

Accept

The paper proposes a method for improving code coverage of an application program that uses database query results for branching. The idea is to profile program execution and identify paths taken by the program. Each branching point that is not taken is an opportunity to improve code coverage. Using this information, it may be possible to invert the branching condition and thereby obtain more tuples from the query results (in a subsequent execution) that might satisfy that branching condition. The paper considers applications issuing a class of single table queries with selection conditions. 

Although the practicality of the proposed method is still unclear, the paper does present an interesting new idea that combines static program analysis and runtime instrumentation (for identifying taken/not-taken paths) with SQL query analysis. It would have been nice to discuss experiences with the prototype on actual database application programs.

